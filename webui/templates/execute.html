[[ define "executePage" ]]
<!doctype html>
<html ng-app="DBHub" ng-controller="executeView">
[[ template "head" . ]]
<body>
<script src="/js/sql-formatter.min.js"></script>
[[ template "header" . ]]
<div>
    <div id="db-header-root"></div>
    <div class="row" ng-if="execNames.length > 0" style="padding-bottom: 10px;">
        <div class="col-md-1">&nbsp;</div>
        <div class="col-md-10">
            <span class="pull-left">
                <div class="dropdown">
                    <div class="btn-group" uib-dropdown keyboard-nav="true">
                        <button id="execName" type="button" class="btn"><span style="font-weight: bold">Saved SQL:</span> <span data-cy="selectedexec">{{ selectedName }}</span></button>

                        <button type="button" uib-dropdown-toggle class="btn btn-default" data-cy="execdropdown">
                            <span class="caret"></span>
                        </button>
                        <ul uib-dropdown-menu class="dropdown-menu" role="menu">
                            <li ng-repeat="exec in execNames" role="menuitem" ng-click="changeExec(exec)" data-cy="exec-{{ exec }}">
                                <a href="">{{ exec }}</a>
                            </li>
                        </ul>
                    </div>
                </div>
            </span>
        </div>
        <div class="col-md-1">&nbsp;</div>
    </div>
    <div class="row">
        <div class="col-md-1">&nbsp;</div>
        <div class="col-md-10">
            <uib-tabset>
                <!-- User defined SQL tab -->
                <uib-tab index="0" data-cy="sqltab">
                    <uib-tab-heading><span style="color: #555;">SQL</span></uib-tab-heading>
                    <textarea id="usersql" rows="8" onchange="updateSQL()" ng-attr-placeholder="Your SQL statement here..." data-cy="usersqltext">[[ .SQL ]]</textarea>
                </uib-tab>
            </uib-tabset>
        </div>
        <div class="col-md-1">&nbsp;</div>
    </div>
    <div style="text-align: center; margin-top: 1%">
        <input type="submit" class="btn" value="Format SQL" ng-click="formatSQL()" data-cy="formatsqlbtn">
        <input type="submit" class="btn btn-success" value="Execute SQL" ng-click="execLiveSQL()" data-cy="execsqlbtn">
        <input type="submit" class="btn btn-primary" value="Save as:" ng-click="saveAs()" data-cy="savebtn">
        <input type="text" id="savename" value="default" data-cy="nameinput">
        <input type="submit" class="btn btn-danger" value="Delete" ng-click="deleteExec()" data-cy="delexecbtn">
    </div>
    <div class="row">
        <div class="col-md-2">&nbsp;</div>
        <div class="col-md-8">
            <div class="row" ng-if="statusMessage != ''">
                <div style="text-align: center; padding-bottom: 8px;">
                    <h4 style="color: {{ statusMessageColour }};" data-cy="statusmsg">&nbsp;{{ statusMessage }}</h4>
                </div>
            </div>
        </div>
        <div class="col-md-2">&nbsp;</div>
    </div>
</div>
[[ template "script_db_header" . ]]
[[ template "footer" . ]]
<script>
    // base64url encode a string
    function base64url(input) {
        let encoded = window.btoa(input);
        encoded = encoded.replace(/=+$/, '');
        encoded = encoded.replace(/\+/g, '-');
        encoded = encoded.replace(/\//g, '_');
        return encoded
    }

    // Pre-filled table row data
    let dataReceived = false;

    // AngularJS can't seem to correctly data-bind a simple textarea, so we have to resort to doing crap like this.
    // Hopefully React is better. :)
    let userSQL = "";
    function updateSQL() {
        // Get the latest .value from the text area
        userSQL = document.getElementById("usersql").value;
    }
    updateSQL();

    // * AngularJS pieces start here *

    // Simple filter to ensure '&nbsp;' is shown as a non-breaking space
    let app = angular.module('DBHub', ['ui.bootstrap', 'ngSanitize']);
    app.filter("fixSpaces", ['$sce', '$sanitize', function($sce, $sanitize) {
        return function(htmlCode) {
            if (htmlCode === "") {
                htmlCode = '&nbsp;';
            }
            return $sanitize(htmlCode);
        }
    }]);

    app.controller('executeView', function($scope, $http, $httpParamSerializerJQLike) {
        // Pre-filled database metadata
        $scope.meta = {
            Branch:       "[[ .DB.Info.Branch ]]",
            BranchList:   [[ .DB.Info.BranchList ]],
            Database:     "[[ .DB.Info.Database ]]",
            Owner:        "[[ .DB.Info.Owner ]]",
            [[ if .PageMeta.LoggedInUser ]]
                Loggedin: "true",
            [[ else ]]
                Loggedin: "false",
            [[ end ]]
        }

        // Initialise things with safe defaults (these are potentially filled out further down the page)
        $scope.selectedName = "[[ .SelectedName ]]";
        $scope.execNames = [[ .ExecNames ]];

        // Change to a newly selected SQL statement
        $scope.changeExec = function(newExec) {
            // Retrieve the newly chosen SQL statement from the server
            $http.get("/x/execget/[[ .DB.Info.Owner ]]/[[ .DB.Info.Database ]]?sqlname="+newExec).then(
                function success(response) {
                    // Clear any existing status message
                    $scope.statusMessage = "";

                    // Apply the retrieved information
                    document.getElementById("savename").value = newExec;
                    $scope.selectedName = newExec;

                    // We include '.textContent' here now because Cypress (v12.3.0) *refuses* to return the correct
                    // data if '.value' is used.  Instead, Cypress returns old data which of course fails every test
                    // using it.  Everything else (Chromium, FF, etc) is totally fine, returning the correct data.
                    // Cypress itself even *visually displays* the correct data that it should be returning.  But no,
                    // the actual .should() call done by Cypress returns *old* (incorrect) data, causing failures.
                    // WTF? :(
                    let txtArea = document.getElementById("usersql");
                    txtArea.textContent = response.data;
                    txtArea.value = response.data;
                    updateSQL();

                }, function failure(response) {
                    // Retrieving statement text failed, so display the returned error message
                    $scope.statusMessageColour = "red";
                    $scope.statusMessage = "Retrieving saved SQL failed: " + response.data;
                }
            )
        }

        // If there are saved SQL statements but none of them is named "default", then change the Saved SQL drop down
        // selector to use the first one
        if (($scope.execNames.length > 0) && (!$scope.execNames.includes("default"))) {
            $scope.changeExec($scope.execNames[0]);
        }

        // Deletes a saved SQL statement
        $scope.deleteExec = function() {
            // Check if the user is logged in
            if ($scope.meta.Loggedin !== "true") {
                // User needs to be logged in
                lock.show();
                return;
            }

            // Make sure the SQL statement is in the front end's "known" list
            let name = document.getElementById("savename").value;
            let arrIdx = $scope.execNames.indexOf(name);
            if (arrIdx > -1) {
                $http.get("/x/execdel/[[ .DB.Info.Owner ]]/[[ .DB.Info.Database ]]?sqlname="+name).then(
                    function success(response) {
                        $scope.statusMessageColour = "green";
                        $scope.statusMessage = "SQL statement '" + name + "' deleted";

                        // Remove the SQL statement from the drop-down list
                        $scope.execNames.splice(arrIdx, 1);

                        // If the currently selected SQL statement is the deleted one, set the current SQL statement name back to default
                        if($scope.selectedName === name) {
                            if ($scope.execNames.length > 0) {
                                let newSelected = $scope.execNames[0];
                                $scope.selectedName = newSelected;
                                document.getElementById("savename").value = newSelected;
                                $scope.changeExec(newSelected);
                            }
                        }
                    }, function failure(response) {
                        // The deletion failed, so display the returned error message
                        $scope.statusMessageColour = "red";
                        $scope.statusMessage = "Deleting '" + name + "' failed: " + response.data;
                    }
                )
            } else {
                $scope.statusMessageColour = "red";
                $scope.statusMessage = "Unknown SQL statement";
            }
        };

        // Execute the SQL statement
        $scope.execLiveSQL = function() {
            // Send the SQL string to the backend
            let encoded = base64url(userSQL);
            $http.get("/x/execlivesql/[[ .DB.Info.Owner ]]/[[ .DB.Info.Database ]]?commit=[[ .DB.Info.CommitID ]]&sql="+encoded).then(
                function success(response) {
                    $scope.statusMessageColour = "green";
                    if (response.data["rows_changed"] === 0) {
                        $scope.statusMessage = "Execution succeeded";
                    } else if (response.data["rows_changed"] === 1) {
                        $scope.statusMessage = "Execution success: " + response.data["rows_changed"] + " row changed";
                    } else {
                        $scope.statusMessage = "Execution success: " + response.data["rows_changed"] + " rows changed";
                    }
                }, function failure(response) {
                    // Retrieving data failed, so display the returned error message and hide the graph
                    $scope.statusMessageColour = "red";
                    $scope.statusMessage = "Executing SQL statement failed: " + response.data;
                }
            )
        };

        // Format the user provided SQL
        $scope.formatSQL = function() {
            let formatted = window.sqlFormatter.format(userSQL, { language: 'sqlite' });
            let txtArea = document.getElementById("usersql");
            txtArea.textContent = formatted;
            txtArea.value = formatted;
            updateSQL();
        };

        // Save the SQL statement for easy later retrieval
        $scope.statusMessage = "";
        $scope.statusMessageColour = "red";
        $scope.saveAs = function() {
            // Check if the user is logged in
            if ($scope.meta.Loggedin !== "true") {
                // User needs to be logged in
                lock.show();
                return;
            }

            let name = document.getElementById("savename").value;
            let args = "sqlname=" + name;
            args += "&sql=" + base64url(userSQL);
            $http.get("/x/execsave/[[ .DB.Info.Owner ]]/[[ .DB.Info.Database ]]?commit=[[ .DB.Info.CommitID ]]&"+args).then(
                function success(response) {
                    $scope.statusMessageColour = "green";
                    $scope.statusMessage = "SQL statement '" + name + "' saved";

                    // Append the new SQL statement to the drop-down list, if it's not already present
                    if ($scope.execNames.indexOf(name) === -1) {
                        $scope.execNames.push(name);
                    }

                    // Set current SQL statement name
                    $scope.selectedName = name
                }, function failure(response) {
                    // The save failed, so display the returned error message
                    $scope.statusMessageColour = "red";
                    $scope.statusMessage = "Saving SQL statement failed: " + response.data;
                }
            )
        };
    });
</script>
</body>
</html>
[[ end ]]
