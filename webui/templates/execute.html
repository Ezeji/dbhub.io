[[ define "executePage" ]]
<!doctype html>
<html ng-app="DBHub" ng-controller="executeView">
[[ template "head" . ]]
<body>
<script src="/js/sql-formatter.min.js"></script>
[[ template "header" . ]]
<div>
    <div id="db-header-root"></div>
    <div class="row" ng-if="execNames.length > 0" style="padding-bottom: 10px;">
        <div class="col-md-1">&nbsp;</div>
        <div class="col-md-10">
            <span class="pull-left">
                <div class="dropdown">
                    <div class="btn-group" uib-dropdown keyboard-nav="true">
                        <button id="execName" type="button" class="btn"><span style="font-weight: bold">Saved SQL:</span> <span data-cy="selectedexec">{{ selectedName }}</span></button>

                        <button type="button" uib-dropdown-toggle class="btn btn-default" data-cy="execdropdown">
                            <span class="caret"></span>
                        </button>
                        <ul uib-dropdown-menu class="dropdown-menu" role="menu">
                            <li ng-repeat="exec in execNames" role="menuitem" ng-click="changeExec(exec, true)" data-cy="exec-{{ exec }}">
                                <a href="">{{ exec }}</a>
                            </li>
                        </ul>
                    </div>
                </div>
            </span>
        </div>
        <div class="col-md-1">&nbsp;</div>
    </div>
    <div class="row">
        <div class="col-md-1">&nbsp;</div>
        <div class="col-md-10">
            <uib-tabset>
                <!-- User defined SQL tab -->
                <uib-tab index="0" data-cy="sqltab">
                    <uib-tab-heading><span style="color: #555;">SQL</span></uib-tab-heading>
                    <textarea id="usersql" rows="8" onchange="updateSQL()" ng-attr-placeholder="Your SQL statement here..." data-cy="usersqltext">[[ .SQL ]]</textarea>

                    <button type="button" class="btn btn-default" ng-if="db.Records.length > 0" ng-click="toggleResultTable()" data-cy="resultsbtn">{{ toggleLabel }}</button>
                    <div uib-collapse="isCollapsed">
                        <div style="max-width: 100%; overflow: auto; border: 1px solid #DDD; border-radius: 7px 7px 0 0;">
                            <table class="table table-bordered table-striped table-responsive" style="margin-bottom: 0; padding-bottom: 0;" data-cy="resultstbl">
                                <thead>
                                <tr>
                                    <th ng-repeat="col in db.ColNames" style="padding: 7px 0 6px 6px;">{{ col }}</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr ng-repeat="row in db.Records">
                                    <td ng-repeat="val in row" dir="auto"><pre style="background-color: transparent; border: none; padding: 0px; margin: 0px;" ng-bind-html="val.Value | fixSpaces"></pre></td>
                                </tr>
                            </table>
                        </div>
                    </div>
                </uib-tab>
            </uib-tabset>
        </div>
        <div class="col-md-1">&nbsp;</div>
    </div>
    <div style="text-align: center; margin-top: 1%">
        <input type="submit" class="btn" value="Format SQL" ng-click="formatSQL()" data-cy="formatsqlbtn">
        <input type="submit" class="btn btn-success" value="Execute SQL" ng-click="execLiveSQL()" data-cy="execsqlbtn">
        <input type="submit" class="btn btn-primary" value="Save as:" ng-click="saveAs()" data-cy="savebtn">
        <input type="text" id="savename" value="default" data-cy="nameinput">
        <input type="submit" class="btn btn-danger" value="Delete" ng-click="deleteExec()" data-cy="delexecbtn">
    </div>
    <div class="row">
        <div class="col-md-2">&nbsp;</div>
        <div class="col-md-8">
            <div class="row" ng-if="statusMessage != ''">
                <div style="text-align: center; padding-bottom: 8px;">
                    <h4 style="color: {{ statusMessageColour }};" data-cy="statusmsg">&nbsp;{{ statusMessage }}</h4>
                </div>
            </div>
        </div>
        <div class="col-md-2">&nbsp;</div>
    </div>
</div>
[[ template "script_db_header" . ]]
[[ template "footer" . ]]
<script>
    // Pre-filled table row data
    let dataReceived = false;

    // AngularJS can't seem to correctly data-bind a simple textarea, so we have to resort to doing crap like this.
    // Hopefully React is better. :)
    let userSQL = "";
    function updateSQL() {
        // Get the latest .value from the text area
        userSQL = document.getElementById("usersql").value;
    }
    updateSQL();

    // * AngularJS pieces start here *

    // Simple filter to ensure '&nbsp;' is shown as a non-breaking space
    let app = angular.module('DBHub', ['ui.bootstrap', 'ngSanitize']);
    app.filter("fixSpaces", ['$sce', '$sanitize', function($sce, $sanitize) {
        return function(htmlCode) {
            if (htmlCode === "") {
                htmlCode = '&nbsp;';
            }
            return $sanitize(htmlCode);
        }
    }]);

    app.controller('executeView', function($scope, $http, $httpParamSerializerJQLike) {
        // Pre-filled database metadata
        $scope.meta = {
            Branch:       "[[ .DB.Info.Branch ]]",
            BranchList:   [[ .DB.Info.BranchList ]],
            Database:     "[[ .DB.Info.Database ]]",
            Owner:        "[[ .DB.Info.Owner ]]",
            [[ if .PageMeta.LoggedInUser ]]
                Loggedin: "true",
            [[ else ]]
                Loggedin: "false",
            [[ end ]]
        }

        // Initialise things with safe defaults (these are potentially filled out further down the page)
        $scope.selectedName = "[[ .SelectedName ]]";
        $scope.execNames = [[ .ExecNames ]];
        $scope.toggleLabel = "Show result table"
        $scope.isCollapsed = true;

        // Create empty stub to hold returned query data
        $scope.db = {"ColCount":0,"ColNames":[],"Offset":0,"Records":[],"RowCount":0,"SortCol":"","SortDir":"","Tablename":"","TotalRows":0};

        // Functions for toggling on/off various display elements
        $scope.toggleResultTable = function() {
            $scope.isCollapsed = !$scope.isCollapsed;
            if ($scope.isCollapsed) {
                $scope.toggleLabel = "Show result table"
            } else {
                $scope.toggleLabel = "Hide result table"
            }

            // Clear any existing status message
            $scope.statusMessage = "";
        }

        // Ensure the SQL statement name field isn't blank
        // Returns true if a name is present, false if it's missing
        $scope.checkName = function() {
            let name = document.getElementById("savename").value;
            if (name === "") {
                $scope.statusMessageColour = "red";
                $scope.statusMessage = nowString() + "Error: Can't do that with a blank SQL statement name";
                return false
            }
            $scope.statusMessageColour = "green";
            $scope.statusMessage = "";
            return true
        }

        // Ensure a SQL statement has been provided
        // Returns true if one is available, false if there's nothing
        $scope.checkSQL = function() {
            if (userSQL === "") {
                $scope.statusMessageColour = "red";
                $scope.statusMessage = nowString() + "Error: You need to write a SQL statement first";
                return false
            }
            $scope.statusMessageColour = "green";
            $scope.statusMessage = "";
            return true
        };

        // Change to a newly selected SQL statement
        $scope.changeExec = function(newExec, updateMsg) {
            // Retrieve the newly chosen SQL statement from the server
            $http.get("/x/execget/[[ .DB.Info.Owner ]]/[[ .DB.Info.Database ]]?sqlname="+newExec).then(
                function success(response) {
                    if (updateMsg) {
                        // Clear any existing status message
                        $scope.statusMessage = "";
                    }

                    // Apply the retrieved information
                    document.getElementById("savename").value = newExec;
                    $scope.selectedName = newExec;

                    // We include '.textContent' here now because Cypress (v12.3.0) *refuses* to return the correct
                    // data if just '.value' is used.  Instead, Cypress returns old data which of course fails every
                    // test using it.  Everything else (Chromium, FF, etc) is totally fine, returning the correct data.
                    // Cypress itself even *visually displays* the correct data that it should be returning.  But no,
                    // the actual .should() call done by Cypress returns *old* (incorrect) data, causing failures.
                    // WTF? :(
                    let txtArea = document.getElementById("usersql");
                    txtArea.textContent = response.data;
                    txtArea.value = response.data;
                    updateSQL();

                }, function failure(response) {
                    if (updateMsg) {
                        // Retrieving statement text failed, so display the returned error message
                        $scope.statusMessageColour = "red";
                        $scope.statusMessage = nowString() + "Retrieving saved SQL failed: " + response.data;
                    }
                }
            )
        }

        // Clear out any existing table data
        $scope.clearData = function() {
            $scope.db.ColNames = [];
            $scope.db.Records = [];
        }

        // If there are saved SQL statements but none of them is named "default", then change the Saved SQL drop down
        // selector to use the first one
        if (($scope.execNames.length > 0) && (!$scope.execNames.includes("default"))) {
            $scope.changeExec($scope.execNames[0], true);
        }

        // Deletes a saved SQL statement
        $scope.deleteExec = function() {
            // Check if the user is logged in
            if ($scope.meta.Loggedin !== "true") {
                // User needs to be logged in
                lock.show();
                return;
            }

            // Ensure the SQL statement name field isn't blank
            if (!$scope.checkName()) return;

            // Make sure the SQL statement is in the front end's "known" list
            let name = document.getElementById("savename").value;
            let arrIdx = $scope.execNames.indexOf(name);
            if (arrIdx > -1) {
                $http.get("/x/execdel/[[ .DB.Info.Owner ]]/[[ .DB.Info.Database ]]?sqlname="+name).then(
                    function success(response) {
                        // Remove the SQL statement from the drop-down list
                        $scope.execNames.splice(arrIdx, 1);

                        // If the currently selected SQL statement is the deleted one, set the current SQL statement name back to default
                        if($scope.selectedName === name) {
                            if ($scope.execNames.length > 0) {
                                let newSelected = $scope.execNames[0];
                                $scope.selectedName = newSelected;
                                document.getElementById("savename").value = newSelected;
                                $scope.changeExec(newSelected, false);
                            }
                        }

                        // Display a success message
                        $scope.statusMessageColour = "green";
                        $scope.statusMessage = nowString() + "SQL statement '" + name + "' deleted";

                        // Clear out any existing table data
                        $scope.clearData();
                    }, function failure(response) {
                        // The deletion failed, so display the returned error message
                        $scope.statusMessageColour = "red";
                        $scope.statusMessage = nowString() + "Deleting '" + name + "' failed: " + response.data;

                        // Clear out any existing table data
                        $scope.clearData();
                    }
                )
            } else {
                $scope.statusMessageColour = "red";
                $scope.statusMessage = nowString() + "Unknown SQL statement";

                // Clear out any existing table data
                $scope.clearData();
            }
        };

        // Execute the SQL statement
        $scope.execLiveSQL = function() {
            // Ensure there's a SQL statement
            if (!$scope.checkSQL()) return;

            // Send the SQL string to the backend
            $http({
                url: "/x/execlivesql/[[ .DB.Info.Owner ]]/[[ .DB.Info.Database ]]",
                method: "post",
                data: {sql: userSQL},
                headers: {'Content-Type': 'application/json'}
            }).then(
                function success(response) {
                    // We can potentially receive either "Execute SQL" or Query responses here
                    if ("rows_changed" in response.data) {
                        // Handle the response as for Execute SQL
                        $scope.statusMessageColour = "green";
                        if (response.data["rows_changed"] === 0) {
                            $scope.statusMessage = nowString() + "Execution succeeded";
                        } else if (response.data["rows_changed"] === 1) {
                            $scope.statusMessage = nowString() + "Execution success: " + response.data["rows_changed"] + " row changed";
                        } else {
                            $scope.statusMessage = nowString() + "Execution success: " + response.data["rows_changed"] + " rows changed";
                        }

                        // Clear out any existing table data
                        $scope.clearData();
                    } else {
                        // Give a useful "success" status message
                        $scope.statusMessageColour = "green";
                        if (response.data["RowCount"] === 0) {
                            $scope.statusMessage = nowString() + "SQL query ran without error, but returned no records";
                            $scope.clearData();
                        } else {
                            $scope.statusMessage = nowString() + "SQL query ran successfully";
                            $scope.db = response.data;
                        }
                    }
                }, function failure(response) {
                    // Retrieving data failed, so display the returned error message and hide the graph
                    $scope.statusMessageColour = "red";
                    $scope.statusMessage = nowString() + "Executing SQL statement failed: " + response.data;

                    // Clear out any existing table data
                    $scope.clearData();
                }
            )
        };

        // Format the user provided SQL
        $scope.formatSQL = function() {
            // Ensure there's a SQL statement
            if (!$scope.checkSQL()) return;

            // Format the SQL
            let formatted = window.sqlFormatter.format(userSQL, { language: 'sqlite' });
            let txtArea = document.getElementById("usersql");
            txtArea.textContent = formatted;
            txtArea.value = formatted;
            updateSQL();
        };

        // Save the SQL statement for easy later retrieval
        $scope.statusMessage = "";
        $scope.statusMessageColour = "red";
        $scope.saveAs = function() {
            // Check if the user is logged in
            if ($scope.meta.Loggedin !== "true") {
                // User needs to be logged in
                lock.show();
                return;
            }

            // Ensure the SQL statement name field isn't blank
            if (!$scope.checkName()) return;

            // Ensure there's a SQL statement
            if (!$scope.checkSQL()) return;

            // Save it
            const name = document.getElementById("savename").value;
            $http({
                url: "/x/execsave/[[ .DB.Info.Owner ]]/[[ .DB.Info.Database ]]",
                method: "post",
                data: {sql_name: name, sql: userSQL},
                headers: {'Content-Type': 'application/json'}
            }).then(
                function success(response) {
                    $scope.statusMessageColour = "green";
                    $scope.statusMessage = nowString() + "SQL statement '" + name + "' saved";

                    // Append the new SQL statement to the drop-down list, if it's not already present
                    if ($scope.execNames.indexOf(name) === -1) {
                        $scope.execNames.push(name);
                    }

                    // Set current SQL statement name
                    $scope.selectedName = name
                }, function failure(response) {
                    // The save failed, so display the returned error message
                    $scope.statusMessageColour = "red";
                    $scope.statusMessage = nowString() + "Saving SQL statement failed: " + response.data;
                }
            )
        };
    });
</script>
</body>
</html>
[[ end ]]
